---
layout: docs
title: Advanced Topics
description: Explore advanced patterns and techniques in DSPy.rb
date: 2025-07-10 00:00:00 +0000
last_modified_at: 2025-07-11 00:00:00 +0000
---
# Advanced Topics

Ready to take your DSPy.rb applications to the next level? This section covers advanced patterns and techniques for building sophisticated LLM systems.

## Advanced Guides

### [DSPy.rb vs LangChain Ruby Comparison](./dspy-vs-langchain/)
Complete framework comparison with benchmarks, migration guide, and use case recommendations for Ruby developers.

### [Memory Systems](./memory-systems/)
Advanced memory management and compaction for stateful agents that need to maintain context over time.

### [Stateful Agents](./stateful-agents/)
Production patterns for building agents that maintain context and state across multiple interactions.

### [Custom Toolsets](./custom-toolsets/)
Build advanced toolsets for specialized agent capabilities like database operations, file handling, and API integrations.

### [Pipelines](./pipelines/)
Build complex multi-stage processing pipelines that combine multiple modules for sophisticated workflows.

### [RAG (Retrieval-Augmented Generation)](./rag/)
Implement retrieval-augmented generation patterns to ground your LLM responses in real data.

### [Rich Types](./complex-types/)
Work with structured data, nested objects, and rich type hierarchies in your signatures.

### [Rails Integration](./rails-integration/)
Integrate DSPy.rb seamlessly with Ruby on Rails applications, including enum handling and service patterns.

### [Custom Metrics](./custom-metrics/)
Build domain-specific metrics to evaluate and optimize your modules for your unique use cases.

## When to Use Advanced Features

Consider these patterns when:
- Building production systems with multiple processing stages
- Working with large knowledge bases or documents
- Handling complex, structured data
- Optimizing for domain-specific requirements

## Best Practices

1. Start simple and add complexity gradually
2. Test each component independently
3. Monitor performance at each stage
4. Use appropriate error handling and fallbacks
