- Baml Schema Format (_articles/baml-schema-format.md)
  - Starting Simple (_articles/baml-schema-format.md:90)
  - Signatures Get Richer (_articles/baml-schema-format.md:134)
  - The Schema Problem (_articles/baml-schema-format.md:173)
  - BAML: The Simple Fix (_articles/baml-schema-format.md:221)
  - Verified Performance (_articles/baml-schema-format.md:240)
    - Token Comparison by Schema Format (_articles/baml-schema-format.md:244)
    - Detailed Performance Breakdown (_articles/baml-schema-format.md:287)
  - How to Use (_articles/baml-schema-format.md:308)
  - When It Matters (_articles/baml-schema-format.md:330)
  - Requirements (_articles/baml-schema-format.md:341)
  - Resources (_articles/baml-schema-format.md:352)
- CodeAct article moved (_articles/codeact-dynamic-code-generation.md)
- Evaluating Llm Applications (_articles/evaluating-llm-applications.md)
  - Why Evaluation Matters (_articles/evaluating-llm-applications.md:14)
  - The Evaluation Workflow (_articles/evaluating-llm-applications.md:25)
  - Example: Tweet Sentiment Classification (_articles/evaluating-llm-applications.md:36)
    - 1. Define Your Task (_articles/evaluating-llm-applications.md:40)
    - 2. Create Test Data (_articles/evaluating-llm-applications.md:80)
  - Basic Evaluation with Built-in Metrics (_articles/evaluating-llm-applications.md:101)
  - Custom Metrics for Domain-Specific Logic (_articles/evaluating-llm-applications.md:120)
  - Advanced Multi-Factor Quality Assessment (_articles/evaluating-llm-applications.md:140)
  - Detailed Result Analysis (_articles/evaluating-llm-applications.md:183)
  - Error Handling (_articles/evaluating-llm-applications.md:208)
  - Integration with Optimization (_articles/evaluating-llm-applications.md:227)
  - Running the Complete Example (_articles/evaluating-llm-applications.md:242)
  - Key Takeaways (_articles/evaluating-llm-applications.md:274)
  - Next Steps (_articles/evaluating-llm-applications.md:282)
- Evaluating Sentiment Classifiers (_articles/evaluating-sentiment-classifiers.md)
  - What We're Building (_articles/evaluating-sentiment-classifiers.md:15)
  - Setting Up the Classifier (_articles/evaluating-sentiment-classifiers.md:22)
  - Creating Test Data (_articles/evaluating-sentiment-classifiers.md:67)
  - Evaluation Level 1: Basic Accuracy (_articles/evaluating-sentiment-classifiers.md:89)
  - Evaluation Level 2: Custom Metrics (_articles/evaluating-sentiment-classifiers.md:111)
  - Evaluation Level 3: Quality Assessment (_articles/evaluating-sentiment-classifiers.md:134)
  - Running the Evaluation (_articles/evaluating-sentiment-classifiers.md:176)
  - Handling Errors Gracefully (_articles/evaluating-sentiment-classifiers.md:206)
  - What You Learn From This (_articles/evaluating-sentiment-classifiers.md:234)
  - Key Takeaways (_articles/evaluating-sentiment-classifiers.md:243)
  - Running the Complete Example (_articles/evaluating-sentiment-classifiers.md:250)
- Json Modes Comparison (_articles/json-modes-comparison.md)
  - Two Strategies Compared (_articles/json-modes-comparison.md:103)
  - Benchmark Results Overview (_articles/json-modes-comparison.md:111)
    - Response Time Comparison by Model (_articles/json-modes-comparison.md:126)
  - Token Consumption Analysis (_articles/json-modes-comparison.md:237)
    - Token Usage by Model and Strategy (_articles/json-modes-comparison.md:241)
    - Token Efficiency by Model Family (_articles/json-modes-comparison.md:260)
    - Cost Comparison: All Models and Strategies (_articles/json-modes-comparison.md:323)
    - Performance by Provider (Average across models) (_articles/json-modes-comparison.md:434)
  - Quick Decision Matrix (_articles/json-modes-comparison.md:477)
  - Key Findings (_articles/json-modes-comparison.md:489)
  - Implementation (_articles/json-modes-comparison.md:500)
  - Recommendations (_articles/json-modes-comparison.md:556)
  - Future: BAML-Inspired Enhanced Prompting (_articles/json-modes-comparison.md:577)
  - Related Articles (_articles/json-modes-comparison.md:591)
- Json Parsing Reliability (_articles/json-parsing-reliability.md)
  - The Problem We're Solving (_articles/json-parsing-reliability.md:17)
  - The Solution: Provider-Optimized Strategies (_articles/json-parsing-reliability.md:41)
    - For OpenAI and Gemini Users (_articles/json-parsing-reliability.md:45)
    - For Anthropic Users (_articles/json-parsing-reliability.md:80)
    - For Everything Else (_articles/json-parsing-reliability.md:93)
  - Reliability Features That Actually Matter (_articles/json-parsing-reliability.md:102)
    - Automatic Retries with Fallback (_articles/json-parsing-reliability.md:104)
    - Smart Caching (_articles/json-parsing-reliability.md:115)
    - Better Error Messages (_articles/json-parsing-reliability.md:125)
  - Configuration Per Provider (_articles/json-parsing-reliability.md:136)
  - Real Performance Impact (_articles/json-parsing-reliability.md:172)
  - Migration is Seamless (_articles/json-parsing-reliability.md:183)
  - What's Next (_articles/json-parsing-reliability.md:205)
  - Try It Now (_articles/json-parsing-reliability.md:213)
- Llm As Judge Ai Sdr Evaluation (_articles/llm-as-judge-ai-sdr-evaluation.md)
  - Why Current Evaluation Approaches Fall Short (_articles/llm-as-judge-ai-sdr-evaluation.md:16)
  - The LLM Judge Approach (_articles/llm-as-judge-ai-sdr-evaluation.md:58)
  - Building the LLM Judge Metric (_articles/llm-as-judge-ai-sdr-evaluation.md:154)
  - Real-World Example: Evaluating AI SDR Campaigns (_articles/llm-as-judge-ai-sdr-evaluation.md:254)
  - Analyzing Judge Feedback (_articles/llm-as-judge-ai-sdr-evaluation.md:329)
  - Advanced: Multi-Judge Consensus (_articles/llm-as-judge-ai-sdr-evaluation.md:356)
  - Integration with Production Systems (_articles/llm-as-judge-ai-sdr-evaluation.md:389)
    - Concurrent Judge Evaluation (_articles/llm-as-judge-ai-sdr-evaluation.md:562)
  - Best Practices (_articles/llm-as-judge-ai-sdr-evaluation.md:593)
    - 1. Judge Calibration (_articles/llm-as-judge-ai-sdr-evaluation.md:595)
    - 2. Prompt Engineering for Judges (_articles/llm-as-judge-ai-sdr-evaluation.md:607)
    - 3. Continuous Improvement (_articles/llm-as-judge-ai-sdr-evaluation.md:628)
  - Key Takeaways (_articles/llm-as-judge-ai-sdr-evaluation.md:643)
  - Beyond Manual Judge Configuration: Optimization (_articles/llm-as-judge-ai-sdr-evaluation.md:654)
- Program Of Thought Deep Dive (_articles/program-of-thought-deep-dive.md)
  - TL;DR (_articles/program-of-thought-deep-dive.md:13)
  - The Core Insight (_articles/program-of-thought-deep-dive.md:25)
  - PoT vs ChainOfThought: The Math Problem (_articles/program-of-thought-deep-dive.md:37)
  - Academic Backing (_articles/program-of-thought-deep-dive.md:73)
  - PoT vs CodeAct: Different Philosophies (_articles/program-of-thought-deep-dive.md:83)
  - When to Use What: The Decision Matrix (_articles/program-of-thought-deep-dive.md:105)
  - The Current State in DSPy (_articles/program-of-thought-deep-dive.md:118)
  - The Skeptical Take (_articles/program-of-thought-deep-dive.md:132)
  - Implementation Challenges (_articles/program-of-thought-deep-dive.md:148)
  - Where PoT Shines (And Where It Doesn't) (_articles/program-of-thought-deep-dive.md:170)
  - The Future: Hybrid Approaches (_articles/program-of-thought-deep-dive.md:189)
  - Should DSPy.rb Add PoT? (_articles/program-of-thought-deep-dive.md:209)
  - Resources to Explore (_articles/program-of-thought-deep-dive.md:220)
  - Bottom Line (_articles/program-of-thought-deep-dive.md:227)
- Raw Chat Api (_articles/raw-chat-api.md)
  - The Problem (_articles/raw-chat-api.md:17)
  - API Overview (_articles/raw-chat-api.md:27)
  - Key Features (_articles/raw-chat-api.md:48)
    - 1. Full Instrumentation Support (_articles/raw-chat-api.md:50)
    - 2. Message Builder DSL (_articles/raw-chat-api.md:62)
    - 3. Streaming Support (_articles/raw-chat-api.md:74)
  - Real-World Example: Changelog Generation (_articles/raw-chat-api.md:84)
  - Integration with Observability (_articles/raw-chat-api.md:138)
  - Migration Strategy (_articles/raw-chat-api.md:155)
    - Phase 1: Baseline (_articles/raw-chat-api.md:159)
    - Phase 2: Prototype (_articles/raw-chat-api.md:165)
    - Phase 3: Compare (_articles/raw-chat-api.md:173)
    - Phase 4: Migrate (_articles/raw-chat-api.md:179)
  - Implementation Details (_articles/raw-chat-api.md:187)
  - Best Practices (_articles/raw-chat-api.md:198)
  - Summary (_articles/raw-chat-api.md:206)
- Ruby Idiomatic Apis (_articles/ruby-idiomatic-apis.md)
  - The Ruby Way vs The Python Way (_articles/ruby-idiomatic-apis.md:15)
  - Embracing Duck Typing (_articles/ruby-idiomatic-apis.md:45)
  - Enumerable All The Way Down (_articles/ruby-idiomatic-apis.md:78)
  - Configuration Blocks, Not YAML (_articles/ruby-idiomatic-apis.md:103)
  - Method Chaining (Coming Soon) (_articles/ruby-idiomatic-apis.md:129)
  - Type Safety Without the Ceremony (_articles/ruby-idiomatic-apis.md:146)
  - Rails Integration First-Class (_articles/ruby-idiomatic-apis.md:169)
  - Introspection and Debugging (_articles/ruby-idiomatic-apis.md:199)
  - What's Next? (_articles/ruby-idiomatic-apis.md:223)
  - Try It Yourself (_articles/ruby-idiomatic-apis.md:257)
- Type Safe Prediction Objects (_articles/type-safe-prediction-objects.md)
  - The Problem: Runtime Surprises (_articles/type-safe-prediction-objects.md:17)
  - The Solution: Know Your Data Structure (_articles/type-safe-prediction-objects.md:31)
  - Three Ways This Saves You Time (_articles/type-safe-prediction-objects.md:59)
    - 1. Catch Errors During Development (_articles/type-safe-prediction-objects.md:61)
    - 2. IDE Autocomplete That Actually Works (_articles/type-safe-prediction-objects.md:80)
    - 3. Self-Documenting Code (_articles/type-safe-prediction-objects.md:95)
  - Real-World Example: Customer Feedback Pipeline (_articles/type-safe-prediction-objects.md:114)
  - The Hidden Benefit: Fearless Refactoring (_articles/type-safe-prediction-objects.md:159)
  - Beyond Strings: Modeling Real-World Relationships (_articles/type-safe-prediction-objects.md:179)
  - Getting Started (_articles/type-safe-prediction-objects.md:241)
  - The Bottom Line (_articles/type-safe-prediction-objects.md:269)
- Under The Hood Json Extraction (_articles/under-the-hood-json-extraction.md)
  - How Strategy Selection Works (_articles/under-the-hood-json-extraction.md:16)
  - OpenAI: Native Structured Outputs (_articles/under-the-hood-json-extraction.md:38)
  - Gemini: Native Structured Outputs (_articles/under-the-hood-json-extraction.md:74)
  - Anthropic: Two Ways to Get JSON (_articles/under-the-hood-json-extraction.md:124)
    - Tool Use Strategy (Priority 95) (_articles/under-the-hood-json-extraction.md:126)
    - 4-Pattern Extraction Strategy (Priority 90) (_articles/under-the-hood-json-extraction.md:164)
  - Enhanced Prompting: Works with Any Model (Priority 50) (_articles/under-the-hood-json-extraction.md:206)
  - Real Examples: What Each Provider Receives (_articles/under-the-hood-json-extraction.md:249)
    - OpenAI Request: (_articles/under-the-hood-json-extraction.md:263)
    - Gemini Request: (_articles/under-the-hood-json-extraction.md:279)
    - Anthropic with Tool Use: (_articles/under-the-hood-json-extraction.md:298)
    - Anthropic with Extraction: (_articles/under-the-hood-json-extraction.md:311)
  - Behind the Scenes (_articles/under-the-hood-json-extraction.md:322)
    - Retry Logic (_articles/under-the-hood-json-extraction.md:324)
    - Performance Characteristics (_articles/under-the-hood-json-extraction.md:353)
  - Try It Yourself (_articles/under-the-hood-json-extraction.md:362)
  - Key Takeaways (_articles/under-the-hood-json-extraction.md:392)
- Union Types Agentic Workflows (_articles/union-types-agentic-workflows.md)
  - The Problem: Decision Paralysis in Code Form (_articles/union-types-agentic-workflows.md:17)
  - Enter Single-Field Union Types: One Decision, Multiple Paths (_articles/union-types-agentic-workflows.md:49)
  - The Magic: Automatic Type Detection (_articles/union-types-agentic-workflows.md:98)
  - The Coffee Shop Agent in Action (_articles/union-types-agentic-workflows.md:165)
  - Running the Agent (_articles/union-types-agentic-workflows.md:228)
  - Why This Matters (_articles/union-types-agentic-workflows.md:306)
    - For Developers (_articles/union-types-agentic-workflows.md:308)
    - For Your AI Application (_articles/union-types-agentic-workflows.md:314)
  - The Pattern in Practice (_articles/union-types-agentic-workflows.md:320)
  - Real-World Applications (_articles/union-types-agentic-workflows.md:334)
    - Customer Service Agents (_articles/union-types-agentic-workflows.md:338)
    - DevOps Automation (_articles/union-types-agentic-workflows.md:361)
    - Code Review Assistant (_articles/union-types-agentic-workflows.md:383)
  - Robustness Against LLM Quirks (_articles/union-types-agentic-workflows.md:407)
  - The Bottom Line (_articles/union-types-agentic-workflows.md:435)
- Rich Types (advanced/complex-types.md)
  - Overview (advanced/complex-types.md:23)
  - Enum Types (advanced/complex-types.md:33)
    - Basic Enums (advanced/complex-types.md:35)
    - String Enum Values (advanced/complex-types.md:65)
    - Multiple Enum Fields (advanced/complex-types.md:91)
  - Struct Types (advanced/complex-types.md:125)
    - Basic Structs (advanced/complex-types.md:127)
    - Nested Structs (advanced/complex-types.md:159)
  - Collection Types (advanced/complex-types.md:188)
    - Arrays (advanced/complex-types.md:190)
    - Arrays of Structs (advanced/complex-types.md:212)
      - Complex Struct Arrays (advanced/complex-types.md:247)
    - Hash Types (advanced/complex-types.md:297)
  - Optional and Nullable Types (advanced/complex-types.md:317)
    - Optional Fields (advanced/complex-types.md:319)
    - Complex Optional Structures (advanced/complex-types.md:345)
  - Union Types (advanced/complex-types.md:369)
    - Basic Union Types (advanced/complex-types.md:373)
    - Union Types with Structs (Single-Field Unions) (advanced/complex-types.md:406)
    - How Automatic Type Conversion Works (advanced/complex-types.md:480)
      - Behind the Scenes (advanced/complex-types.md:490)
    - Union Types in Arrays (advanced/complex-types.md:511)
    - Best Practices for Union Types (advanced/complex-types.md:554)
  - Automatic Type Conversion with DSPy::Prediction (advanced/complex-types.md:601)
    - How It Works (advanced/complex-types.md:605)
    - Example: Automatic Conversion in Action (advanced/complex-types.md:614)
    - Conversion Features (advanced/complex-types.md:657)
      - 1. Deep Nesting Support (advanced/complex-types.md:659)
      - 2. Union Type Handling (advanced/complex-types.md:681)
      - 3. Edge Cases (advanced/complex-types.md:693)
    - Performance Considerations (advanced/complex-types.md:700)
    - Limitations (advanced/complex-types.md:707)
  - Working with Complex Results (advanced/complex-types.md:714)
    - Accessing Nested Data (advanced/complex-types.md:716)
    - Validation and Error Handling (advanced/complex-types.md:737)
  - Schema Format Options (advanced/complex-types.md:760)
    - JSON Schema (Default) (advanced/complex-types.md:764)
    - BAML Schema Format (New in v0.13.0) (advanced/complex-types.md:783)
  - Best Practices (advanced/complex-types.md:834)
    - 1. Use Descriptive Names (advanced/complex-types.md:836)
    - 2. Handle Missing Data Gracefully (advanced/complex-types.md:857)
    - 3. Use Validation in Your Logic (advanced/complex-types.md:887)
    - 4. Design for LLM Understanding (advanced/complex-types.md:907)
  - Limitations and Best Practices (advanced/complex-types.md:928)
    - Nesting Depth Limitations (advanced/complex-types.md:930)
    - Performance Considerations (advanced/complex-types.md:974)
    - Troubleshooting Rich Types (advanced/complex-types.md:992)
- Custom Metrics (advanced/custom-metrics.md)
  - Overview (advanced/custom-metrics.md:22)
  - Basic Custom Metrics (advanced/custom-metrics.md:30)
    - Simple Custom Metric (advanced/custom-metrics.md:32)
    - Weighted Accuracy Metric (advanced/custom-metrics.md:50)
    - Confidence-Aware Metric (advanced/custom-metrics.md:73)
  - Domain-Specific Metrics (advanced/custom-metrics.md:95)
    - Customer Service Quality Metric (advanced/custom-metrics.md:97)
    - Medical Information Accuracy Metric (advanced/custom-metrics.md:144)
    - Financial Risk Assessment Metric (advanced/custom-metrics.md:185)
  - Multi-Objective Metrics (advanced/custom-metrics.md:241)
    - Composite Quality Metric (advanced/custom-metrics.md:243)
    - Business ROI Metric (advanced/custom-metrics.md:293)
  - Evaluation with Custom Metrics (advanced/custom-metrics.md:331)
    - Using Multiple Metrics (advanced/custom-metrics.md:333)
    - Detailed Result Analysis (advanced/custom-metrics.md:374)
  - Integration with Optimization (advanced/custom-metrics.md:425)
    - Custom Metric in MIPROv2 (advanced/custom-metrics.md:427)
  - Best Practices (advanced/custom-metrics.md:446)
    - 1. Clear Scoring Logic (advanced/custom-metrics.md:448)
    - 2. Handle Edge Cases (advanced/custom-metrics.md:470)
    - 3. Consistent Return Values (advanced/custom-metrics.md:488)
    - 4. Meaningful Metrics (advanced/custom-metrics.md:502)
- Custom Toolsets (advanced/custom-toolsets.md)
  - Toolset Architecture (advanced/custom-toolsets.md:23)
    - Base Toolset Structure (advanced/custom-toolsets.md:25)
    - Tool Method Requirements (advanced/custom-toolsets.md:58)
    - Advanced Type Support (advanced/custom-toolsets.md:65)
  - Production Toolset Examples (advanced/custom-toolsets.md:129)
    - 1. Simple Data Storage Toolset (advanced/custom-toolsets.md:131)
    - 2. File System Operations Toolset (advanced/custom-toolsets.md:202)
    - 3. HTTP API Client Toolset (advanced/custom-toolsets.md:348)
    - 4. Text Processing Toolset (advanced/custom-toolsets.md:491)
  - Advanced Patterns (advanced/custom-toolsets.md:659)
    - 1. Stateful Toolsets (advanced/custom-toolsets.md:661)
    - 2. Async Toolsets (advanced/custom-toolsets.md:728)
    - 3. Validation and Security (advanced/custom-toolsets.md:810)
  - Testing Custom Toolsets (advanced/custom-toolsets.md:902)
    - Unit Testing (advanced/custom-toolsets.md:904)
    - Integration Testing (advanced/custom-toolsets.md:948)
  - Best Practices (advanced/custom-toolsets.md:982)
    - 1. Error Handling (advanced/custom-toolsets.md:984)
    - 2. Input Validation (advanced/custom-toolsets.md:1005)
    - 3. Resource Management (advanced/custom-toolsets.md:1022)
    - 4. Documentation (advanced/custom-toolsets.md:1041)
  - Performance Considerations (advanced/custom-toolsets.md:1051)
    - 1. Lazy Loading (advanced/custom-toolsets.md:1053)
    - 2. Connection Pooling (advanced/custom-toolsets.md:1073)
    - 3. Caching (advanced/custom-toolsets.md:1091)
- DSPy.rb vs LangChain Ruby: The Complete Framework Comparison (advanced/dspy-vs-langchain.md)
  - TL;DR: Which Framework Should You Choose? (advanced/dspy-vs-langchain.md:18)
  - Architecture Philosophy (advanced/dspy-vs-langchain.md:28)
    - DSPy.rb: Programming, Not Prompting (advanced/dspy-vs-langchain.md:30)
    - LangChain.rb: Component Assembly (advanced/dspy-vs-langchain.md:44)
  - Performance Benchmarks (advanced/dspy-vs-langchain.md:56)
    - Response Time (100 requests, GPT-4) (advanced/dspy-vs-langchain.md:58)
    - Memory Usage (advanced/dspy-vs-langchain.md:62)
    - Code Maintainability (Cyclomatic Complexity) (advanced/dspy-vs-langchain.md:66)
  - Feature Comparison (advanced/dspy-vs-langchain.md:72)
  - Real-World Use Cases (advanced/dspy-vs-langchain.md:85)
    - 1. Production RAG System (advanced/dspy-vs-langchain.md:87)
    - 2. Complex Multi-Step Reasoning (advanced/dspy-vs-langchain.md:125)
  - Migration Guide: LangChain.rb ‚Üí DSPy.rb (advanced/dspy-vs-langchain.md:148)
    - 1. Simple LLM Calls (advanced/dspy-vs-langchain.md:150)
    - 2. Chain of Operations (advanced/dspy-vs-langchain.md:166)
  - Production Considerations (advanced/dspy-vs-langchain.md:188)
    - DSPy.rb Advantages (advanced/dspy-vs-langchain.md:190)
    - LangChain.rb Advantages (advanced/dspy-vs-langchain.md:197)
  - Performance Optimization Tips (advanced/dspy-vs-langchain.md:203)
    - DSPy.rb (advanced/dspy-vs-langchain.md:205)
    - LangChain.rb (advanced/dspy-vs-langchain.md:220)
  - Cost Analysis (advanced/dspy-vs-langchain.md:229)
    - Token Usage (1000 operations) (advanced/dspy-vs-langchain.md:231)
    - Development Time (advanced/dspy-vs-langchain.md:235)
  - When to Choose Each Framework (advanced/dspy-vs-langchain.md:239)
    - Choose DSPy.rb When: (advanced/dspy-vs-langchain.md:241)
    - Choose LangChain.rb When: (advanced/dspy-vs-langchain.md:248)
  - Future Roadmap (advanced/dspy-vs-langchain.md:255)
    - DSPy.rb (2025) (advanced/dspy-vs-langchain.md:257)
    - LangChain.rb (2025) (advanced/dspy-vs-langchain.md:263)
  - Conclusion (advanced/dspy-vs-langchain.md:269)
  - Next Steps (advanced/dspy-vs-langchain.md:278)
  - Related Topics (advanced/dspy-vs-langchain.md:288)
    - Getting Started with DSPy.rb (advanced/dspy-vs-langchain.md:290)
    - Core Concepts (advanced/dspy-vs-langchain.md:295)
    - Advanced Patterns (advanced/dspy-vs-langchain.md:300)
    - Optimization (advanced/dspy-vs-langchain.md:305)
    - Production (advanced/dspy-vs-langchain.md:309)
- Advanced Topics (advanced/index.md)
  - Advanced Guides (advanced/index.md:12)
    - [DSPy.rb vs LangChain Ruby Comparison](./dspy-vs-langchain/) (advanced/index.md:14)
    - [Memory Systems](./memory-systems/) (advanced/index.md:17)
    - [Stateful Agents](./stateful-agents/) (advanced/index.md:20)
    - [Custom Toolsets](./custom-toolsets/) (advanced/index.md:23)
    - [Pipelines](./pipelines/) (advanced/index.md:26)
    - [RAG (Retrieval-Augmented Generation)](./rag/) (advanced/index.md:29)
    - [Rich Types](./complex-types/) (advanced/index.md:32)
    - [Rails Integration](./rails-integration/) (advanced/index.md:35)
    - [Custom Metrics](./custom-metrics/) (advanced/index.md:38)
  - When to Use Advanced Features (advanced/index.md:41)
  - Best Practices (advanced/index.md:49)
- Multi-stage Pipelines (advanced/pipelines.md)
  - Overview (advanced/pipelines.md:22)
  - Basic Pipeline Concepts (advanced/pipelines.md:31)
    - Module-Based Architecture (advanced/pipelines.md:33)
    - Sequential Pipeline (advanced/pipelines.md:72)
  - Advanced Pipeline Patterns (advanced/pipelines.md:107)
    - Conditional Processing (advanced/pipelines.md:109)
    - Pipeline with Error Handling (advanced/pipelines.md:151)
    - Data Transformation Pipeline (advanced/pipelines.md:200)
  - Parallel Processing Simulation (advanced/pipelines.md:255)
  - Pipeline Optimization (advanced/pipelines.md:302)
    - Caching Pipeline Results (advanced/pipelines.md:304)
    - Performance Monitoring (advanced/pipelines.md:349)
  - Complex Pipeline Example (advanced/pipelines.md:413)
  - Best Practices (advanced/pipelines.md:537)
    - 1. Modular Design (advanced/pipelines.md:539)
    - 2. Error Recovery (advanced/pipelines.md:558)
    - 3. Pipeline Testing (advanced/pipelines.md:577)
    - 4. Performance Considerations (advanced/pipelines.md:602)
- DSPy Python vs DSPy.rb Feature Comparison (advanced/python-comparison.md)
  - Core Modules/Predictors (advanced/python-comparison.md:18)
    - Available in Both Python and Ruby (advanced/python-comparison.md:20)
    - Available in Python but NOT in Ruby (advanced/python-comparison.md:25)
    - Ruby-Specific Modules (Not in Python) (advanced/python-comparison.md:33)
  - Optimization Techniques (advanced/python-comparison.md:36)
    - Available in Both (advanced/python-comparison.md:38)
    - Available in Python but NOT in Ruby (advanced/python-comparison.md:41)
  - Advanced Features (advanced/python-comparison.md:50)
    - Retrievers and Vector Stores (advanced/python-comparison.md:52)
      - Python DSPy (advanced/python-comparison.md:54)
      - Ruby DSPy (advanced/python-comparison.md:64)
    - Type System and Validation (advanced/python-comparison.md:70)
      - Python DSPy (advanced/python-comparison.md:72)
      - Ruby DSPy (advanced/python-comparison.md:78)
    - Tool Support (advanced/python-comparison.md:83)
      - Python DSPy (advanced/python-comparison.md:85)
      - Ruby DSPy (advanced/python-comparison.md:89)
    - Production Features (advanced/python-comparison.md:95)
      - Python DSPy (advanced/python-comparison.md:97)
      - Ruby DSPy (More Advanced) (advanced/python-comparison.md:101)
  - Missing Components That Should Be Prioritized (advanced/python-comparison.md:115)
    - High Priority (Core Functionality Gaps) (advanced/python-comparison.md:117)
    - Medium Priority (Enhanced Capabilities) (advanced/python-comparison.md:138)
    - Lower Priority (Nice to Have) (advanced/python-comparison.md:156)
  - Ruby DSPy Advantages (advanced/python-comparison.md:166)
  - Recommendations (advanced/python-comparison.md:174)
- Examples (core-concepts/examples.md)
  - Creating Basic Examples (core-concepts/examples.md:23)
  - Type Safety and Validation (core-concepts/examples.md:76)
  - Working with Examples (core-concepts/examples.md:93)
    - Accessing Example Data (core-concepts/examples.md:95)
    - Evaluating Predictions (core-concepts/examples.md:117)
    - Batch Validation (core-concepts/examples.md:132)
  - Few-Shot Examples (core-concepts/examples.md:151)
    - Working with FewShotExample (core-concepts/examples.md:177)
    - Serialization (core-concepts/examples.md:203)
  - Testing Examples (core-concepts/examples.md:223)
    - Integration with Evaluation (core-concepts/examples.md:257)
  - Usage with ChainOfThought (core-concepts/examples.md:285)
  - Best Practices (core-concepts/examples.md:305)
    - 1. Balanced Examples (core-concepts/examples.md:307)
    - 2. Include Edge Cases (core-concepts/examples.md:321)
    - 3. Type Safety (core-concepts/examples.md:342)
- Core Concepts (core-concepts/index.md)
  - The Building Blocks (core-concepts/index.md:12)
    - [Signatures](./signatures/) (core-concepts/index.md:16)
    - [Modules](./modules/) (core-concepts/index.md:19)
    - [Module Runtime Context](./module-runtime-context/) (core-concepts/index.md:22)
    - [Event System](./events/) (core-concepts/index.md:25)
    - [Memory](./memory/) (core-concepts/index.md:28)
    - [Toolsets](./toolsets/) (core-concepts/index.md:31)
    - [Predictors](./predictors/) (core-concepts/index.md:34)
    - [CodeAct](./codeact/) _(requires the `dspy-code_act` gem)_ (core-concepts/index.md:37)
    - [Multimodal](./multimodal/) (core-concepts/index.md:40)
    - [Examples](./examples/) (core-concepts/index.md:43)
  - Start Learning (core-concepts/index.md:46)
- Modules (core-concepts/modules.md)
  - Overview (core-concepts/modules.md:24)
  - Basic Module Structure (core-concepts/modules.md:32)
    - Creating a Custom Module (core-concepts/modules.md:34)
    - Module with Configuration (core-concepts/modules.md:71)
  - Runtime Context Guidance (core-concepts/modules.md:106)
  - Manual Module Composition (core-concepts/modules.md:111)
    - Sequential Processing (core-concepts/modules.md:113)
    - Conditional Processing (core-concepts/modules.md:146)
  - Working with Different Predictors (core-concepts/modules.md:172)
    - Module Using Chain of Thought (core-concepts/modules.md:174)
    - Module Using ReAct for Tool Integration (core-concepts/modules.md:213)
    - Complete Example: Personal Assistant with Memory (core-concepts/modules.md:249)
    - Building a Stateful Customer Service Agent (core-concepts/modules.md:311)
    - Module Using CodeAct for Dynamic Programming (core-concepts/modules.md:396)
  - Extensibility (core-concepts/modules.md:400)
    - Creating Custom Modules (core-concepts/modules.md:402)
  - Testing Modules (core-concepts/modules.md:465)
    - Basic Module Testing (core-concepts/modules.md:467)
    - Testing Module Composition (core-concepts/modules.md:491)
  - Best Practices (core-concepts/modules.md:508)
    - 1. Single Responsibility (core-concepts/modules.md:510)
    - 2. Clear Interfaces with Signatures (core-concepts/modules.md:545)
  - Instruction Update Contract (core-concepts/modules.md:574)
  - Basic Optimization Support (core-concepts/modules.md:608)
- Multimodal Support (core-concepts/multimodal.md)
  - Vision-Capable Models (core-concepts/multimodal.md:16)
    - OpenAI Models (core-concepts/multimodal.md:18)
    - Anthropic Models (core-concepts/multimodal.md:23)
    - Google Gemini Models (core-concepts/multimodal.md:28)
  - Working with Images (core-concepts/multimodal.md:33)
    - Creating Images (core-concepts/multimodal.md:35)
    - Supported Formats (core-concepts/multimodal.md:66)
    - Size Limits (core-concepts/multimodal.md:72)
  - Using Images with LM (core-concepts/multimodal.md:76)
    - Simple Image Analysis (core-concepts/multimodal.md:78)
    - Multiple Images (core-concepts/multimodal.md:95)
    - With System Prompts (core-concepts/multimodal.md:109)
  - Structured Multimodal Signatures (core-concepts/multimodal.md:118)
    - Image Analysis with Structured Output (core-concepts/multimodal.md:122)
    - Object Detection with Type-Safe Bounding Boxes (core-concepts/multimodal.md:170)
  - Working with Anthropic Models (core-concepts/multimodal.md:229)
  - Working with Google Gemini Models (core-concepts/multimodal.md:256)
    - Multiple Images with Gemini (core-concepts/multimodal.md:283)
  - Platform Differences (core-concepts/multimodal.md:306)
    - OpenAI (core-concepts/multimodal.md:308)
    - Anthropic (core-concepts/multimodal.md:313)
    - Google Gemini (core-concepts/multimodal.md:319)
  - Error Handling (core-concepts/multimodal.md:325)
  - Best Practices (core-concepts/multimodal.md:367)
  - Example: Object Detection (core-concepts/multimodal.md:375)
  - Token Usage Considerations (core-concepts/multimodal.md:396)
  - Limitations (core-concepts/multimodal.md:412)
  - Examples (core-concepts/multimodal.md:420)
    - Bounding Box Detection (core-concepts/multimodal.md:424)
    - Image Analysis (core-concepts/multimodal.md:429)
  - Next Steps (core-concepts/multimodal.md:440)
- Predictors (core-concepts/predictors.md)
  - DSPy::Predict (core-concepts/predictors.md:24)
    - Basic Usage (core-concepts/predictors.md:28)
    - Basic Configuration (core-concepts/predictors.md:62)
  - DSPy::ChainOfThought (core-concepts/predictors.md:72)
    - When to Use ChainOfThought (core-concepts/predictors.md:76)
    - Basic Usage (core-concepts/predictors.md:83)
    - Working with Reasoning (core-concepts/predictors.md:107)
  - DSPy::ReAct (core-concepts/predictors.md:142)
    - Tool Definition (core-concepts/predictors.md:146)
    - ReAct Agent Usage (core-concepts/predictors.md:183)
    - Custom Tool Integration (core-concepts/predictors.md:229)
  - DSPy::CodeAct (core-concepts/predictors.md:271)
  - Predictor Comparison (core-concepts/predictors.md:281)
    - Performance Characteristics (core-concepts/predictors.md:283)
    - Concurrent Performance Gains (core-concepts/predictors.md:292)
    - Choosing the Right Predictor (core-concepts/predictors.md:300)
  - Error Handling (core-concepts/predictors.md:316)
    - Basic Error Handling (core-concepts/predictors.md:318)
    - Input Validation (core-concepts/predictors.md:336)
  - Prompt Optimization (core-concepts/predictors.md:357)
    - Working with Examples (core-concepts/predictors.md:359)
    - Custom Instructions (core-concepts/predictors.md:380)
  - Testing Predictors (core-concepts/predictors.md:392)
    - Unit Tests (core-concepts/predictors.md:394)
    - Testing ChainOfThought (core-concepts/predictors.md:418)
  - Concurrent Predictions (core-concepts/predictors.md:437)
    - When to Use Concurrent Predictions (core-concepts/predictors.md:441)
    - Basic Concurrent Pattern (core-concepts/predictors.md:448)
    - Performance Benefits (core-concepts/predictors.md:500)
    - Real-World Example (core-concepts/predictors.md:529)
    - Error Handling in Concurrent Predictions (core-concepts/predictors.md:584)
    - Requirements (core-concepts/predictors.md:608)
    - Best Practices for Concurrent Predictions (core-concepts/predictors.md:621)
  - Best Practices (core-concepts/predictors.md:629)
    - 1. Choose the Right Predictor (core-concepts/predictors.md:631)
    - 2. Handle Errors Gracefully (core-concepts/predictors.md:644)
    - 3. Use Built-in Observability (core-concepts/predictors.md:658)
- Signatures (core-concepts/signatures.md)
  - Basic Signature Structure (core-concepts/signatures.md:24)
  - Input Definition (core-concepts/signatures.md:40)
    - Supported Types (core-concepts/signatures.md:42)
  - Date and Time Types (core-concepts/signatures.md:62)
    - Date/Time Format Handling (core-concepts/signatures.md:85)
    - Timezone Considerations (core-concepts/signatures.md:103)
  - Output Definition (core-concepts/signatures.md:110)
    - Using Enums for Controlled Outputs (core-concepts/signatures.md:112)
    - Using Structs for Structured Outputs (core-concepts/signatures.md:138)
  - Union Types (core-concepts/signatures.md:169)
  - Optional Fields (core-concepts/signatures.md:191)
  - Default Values (New in v0.7.0) (core-concepts/signatures.md:211)
    - How Default Values Work (core-concepts/signatures.md:245)
  - Practical Examples (core-concepts/signatures.md:255)
    - Email Classification (core-concepts/signatures.md:257)
    - Product Review Analysis (core-concepts/signatures.md:286)
  - Schema Formats (core-concepts/signatures.md:305)
    - JSON Schema (Default) (core-concepts/signatures.md:309)
    - BAML Schema Format (New in v0.28.2) (core-concepts/signatures.md:342)
  - Usage with Predictors (core-concepts/signatures.md:426)
    - Automatic Type Conversion (v0.9.0+) (core-concepts/signatures.md:445)
  - Testing Signatures (core-concepts/signatures.md:455)
  - Special Considerations (core-concepts/signatures.md:484)
    - Working with ChainOfThought (core-concepts/signatures.md:486)
  - Best Practices (core-concepts/signatures.md:516)
    - 1. Clear and Specific Descriptions (core-concepts/signatures.md:518)
    - 2. Meaningful Enum Values (core-concepts/signatures.md:528)
    - 3. Use Optional Fields Appropriately (core-concepts/signatures.md:551)
- Toolsets (core-concepts/toolsets-guide.md)
  - When to Use Toolsets (core-concepts/toolsets-guide.md:12)
  - Basic Usage (core-concepts/toolsets-guide.md:21)
  - Memory Toolset Example (core-concepts/toolsets-guide.md:47)
  - How It Works (core-concepts/toolsets-guide.md:71)
  - DSL Methods (core-concepts/toolsets-guide.md:78)
    - `toolset_name(name)` (core-concepts/toolsets-guide.md:80)
    - `tool(method_name, options)` (core-concepts/toolsets-guide.md:92)
  - Type Safety (core-concepts/toolsets-guide.md:102)
  - Memory Operations (core-concepts/toolsets-guide.md:127)
  - LLM Usage (core-concepts/toolsets-guide.md:141)
  - Testing (core-concepts/toolsets-guide.md:157)
  - Limitations (core-concepts/toolsets-guide.md:177)
  - Next Steps (core-concepts/toolsets-guide.md:183)
  - Design Decisions (core-concepts/toolsets-guide.md:194)
- Toolsets (core-concepts/toolsets.md)
  - When to Use Toolsets (core-concepts/toolsets.md:23)
  - Basic Usage (core-concepts/toolsets.md:32)
  - Memory Toolset Example (core-concepts/toolsets.md:68)
  - How It Works (core-concepts/toolsets.md:107)
  - DSL Methods (core-concepts/toolsets.md:114)
    - `toolset_name(name)` (core-concepts/toolsets.md:116)
    - `tool(method_name, options)` (core-concepts/toolsets.md:128)
  - Type Safety (core-concepts/toolsets.md:138)
    - Basic Types (core-concepts/toolsets.md:142)
    - Enums (core-concepts/toolsets.md:157)
    - Structs (core-concepts/toolsets.md:196)
    - Collections (core-concepts/toolsets.md:222)
    - Nilable Types (core-concepts/toolsets.md:238)
    - Union Types (core-concepts/toolsets.md:254)
  - Supported Sorbet Types Reference (core-concepts/toolsets.md:268)
  - Schema Generation Examples (core-concepts/toolsets.md:285)
  - Memory Operations (core-concepts/toolsets.md:354)
  - LLM Usage (core-concepts/toolsets.md:368)
  - Testing (core-concepts/toolsets.md:384)
  - Limitations (core-concepts/toolsets.md:404)
  - Next Steps (core-concepts/toolsets.md:410)
  - Design Decisions (core-concepts/toolsets.md:416)
- Core Concepts (getting-started/core-concepts.md)
  - Signatures: Defining LLM Interfaces (getting-started/core-concepts.md:23)
    - Key Features (getting-started/core-concepts.md:51)
  - Predictors: Basic LLM Operations (getting-started/core-concepts.md:58)
    - DSPy::Predict (getting-started/core-concepts.md:62)
    - DSPy::ChainOfThought (getting-started/core-concepts.md:75)
    - DSPy::ReAct (getting-started/core-concepts.md:94)
  - Modules: Composing Complex Workflows (getting-started/core-concepts.md:135)
  - Examples: Type-Safe Training Data (getting-started/core-concepts.md:159)
  - Configuration: Setting Up Your Environment (getting-started/core-concepts.md:195)
    - Language Model Options (getting-started/core-concepts.md:208)
    - Raw Chat API (getting-started/core-concepts.md:226)
  - Error Handling and Validation (getting-started/core-concepts.md:255)
  - Best Practices (getting-started/core-concepts.md:270)
    - 1. Start Simple (getting-started/core-concepts.md:272)
    - 2. Use Clear Descriptions (getting-started/core-concepts.md:286)
    - 3. Leverage Type Safety (getting-started/core-concepts.md:297)
    - 4. Compose Thoughtfully (getting-started/core-concepts.md:317)
  - Next Steps (getting-started/core-concepts.md:341)
  - Common Patterns (getting-started/core-concepts.md:348)
    - Multi-Step Processing (getting-started/core-concepts.md:350)
    - Conditional Routing (getting-started/core-concepts.md:363)
    - Error Recovery (getting-started/core-concepts.md:378)
- Your First Structured AI Program (getting-started/first-program.md)
  - What We're Building (getting-started/first-program.md:12)
  - Setting Up (getting-started/first-program.md:22)
  - The Old Way vs. The New Way (getting-started/first-program.md:39)
    - **The Fragile Approach** (getting-started/first-program.md:43)
    - **The Structured Approach** (getting-started/first-program.md:60)
  - Understanding What Just Happened (getting-started/first-program.md:86)
    - **1. Clear Interface Definition** (getting-started/first-program.md:88)
    - **2. Predictable Module Creation** (getting-started/first-program.md:109)
    - **3. Structured Results** (getting-started/first-program.md:117)
  - Making It More Sophisticated (getting-started/first-program.md:127)
  - Making It More Sophisticated with Advanced Sorbet Types (getting-started/first-program.md:167)
  - Building ReAct Agents with Ruby Types (getting-started/first-program.md:214)
  - Adding Error Handling (getting-started/first-program.md:277)
  - Testing Your System (getting-started/first-program.md:307)
  - What You've Accomplished (getting-started/first-program.md:351)
  - Reflection Questions (getting-started/first-program.md:361)
  - Your Next Steps (getting-started/first-program.md:375)
    - **üîß Deepen Your Understanding** (getting-started/first-program.md:379)
    - **üèóÔ∏è Build More Complex Systems** (getting-started/first-program.md:383)
    - **ü§ù Create AI That Uses Tools** (getting-started/first-program.md:387)
  - The Path Forward (getting-started/first-program.md:391)
- Getting Started with DSPy.rb (getting-started/index.md)
  - What is DSPy.rb? (getting-started/index.md:16)
  - Key Features (getting-started/index.md:20)
  - Quick Example (getting-started/index.md:27)
  - What's Next? (getting-started/index.md:63)
- Installation & Setup (getting-started/installation.md)
  - Installation (getting-started/installation.md:21)
  - Required Dependencies (getting-started/installation.md:41)
  - Observability (getting-started/installation.md:52)
  - Configuration (getting-started/installation.md:56)
    - Basic Configuration (getting-started/installation.md:58)
    - Environment Variables (getting-started/installation.md:73)
    - Advanced Configuration (getting-started/installation.md:97)
  - Provider Setup (getting-started/installation.md:111)
    - OpenAI Setup (getting-started/installation.md:113)
    - Anthropic Setup (getting-started/installation.md:128)
    - OpenRouter Setup (Multiple Providers) (getting-started/installation.md:143)
    - Ollama Setup (Local Models) (getting-started/installation.md:188)
    - Structured Outputs Support (getting-started/installation.md:211)
  - Verification (getting-started/installation.md:252)
  - Troubleshooting (getting-started/installation.md:283)
    - Common Issues (getting-started/installation.md:285)
    - Getting Help (getting-started/installation.md:307)
- Quick Start Guide (getting-started/quick-start.md)
  - Your First DSPy Program (getting-started/quick-start.md:23)
    - Basic Prediction (getting-started/quick-start.md:25)
    - Chain of Thought Reasoning (getting-started/quick-start.md:72)
    - Multi-stage Pipelines (getting-started/quick-start.md:95)
  - Ruby-Idiomatic Examples (getting-started/quick-start.md:156)
    - Working with Collections (getting-started/quick-start.md:158)
    - Block-Based Configuration (getting-started/quick-start.md:188)
    - Duck Typing with Tools (getting-started/quick-start.md:207)
  - Key Concepts (getting-started/quick-start.md:252)
    - Signatures (getting-started/quick-start.md:254)
    - Predictors (getting-started/quick-start.md:272)
    - Modules (getting-started/quick-start.md:281)
  - Next Steps (getting-started/quick-start.md:301)
- Benchmarking Raw Prompts (optimization/benchmarking-raw-prompts.md)
  - Why Benchmark Raw Prompts? (optimization/benchmarking-raw-prompts.md:13)
  - Using raw_chat (optimization/benchmarking-raw-prompts.md:20)
    - Array Format (optimization/benchmarking-raw-prompts.md:24)
    - DSL Format (optimization/benchmarking-raw-prompts.md:38)
  - Capturing Observability Data (optimization/benchmarking-raw-prompts.md:49)
  - Complete Benchmarking Example (optimization/benchmarking-raw-prompts.md:97)
  - Advanced Benchmarking with Multiple Providers (optimization/benchmarking-raw-prompts.md:214)
  - Integration with Observability Tools (optimization/benchmarking-raw-prompts.md:254)
  - Benchmarking Schema Formats (optimization/benchmarking-raw-prompts.md:271)
  - Best Practices (optimization/benchmarking-raw-prompts.md:338)
  - Migration Strategy (optimization/benchmarking-raw-prompts.md:347)
  - Conclusion (optimization/benchmarking-raw-prompts.md:369)
- Evaluation Framework (optimization/evaluation.md)
  - Overview (optimization/evaluation.md:22)
  - Basic Usage (optimization/evaluation.md:31)
    - Simple Evaluation (optimization/evaluation.md:33)
    - Built-in Metrics (optimization/evaluation.md:55)
  - Observability Hooks (optimization/evaluation.md:88)
  - Custom Metrics (optimization/evaluation.md:115)
    - Defining Custom Metrics (optimization/evaluation.md:117)
    - Complex Custom Metrics (optimization/evaluation.md:129)
  - Evaluation Results (optimization/evaluation.md:159)
    - Working with Results (optimization/evaluation.md:161)
    - Batch Results (optimization/evaluation.md:186)
  - Display Options (optimization/evaluation.md:195)
    - Table Display (optimization/evaluation.md:197)
    - Custom Display (optimization/evaluation.md:215)
  - Error Handling (optimization/evaluation.md:239)
    - Graceful Error Handling (optimization/evaluation.md:241)
  - Multi-Threading (optimization/evaluation.md:263)
  - Integration with Optimizers (optimization/evaluation.md:278)
    - Evaluation in Optimization (optimization/evaluation.md:280)
  - Best Practices (optimization/evaluation.md:308)
    - 1. Choose Appropriate Metrics (optimization/evaluation.md:310)
    - 2. Handle Edge Cases (optimization/evaluation.md:329)
    - 3. Meaningful Error Messages (optimization/evaluation.md:347)
    - 4. Batch Size Considerations (optimization/evaluation.md:362)
- GEPA Optimizer (optimization/gepa.md)
  - Installation (optimization/gepa.md:25)
  - Overview (optimization/gepa.md:36)
  - Quickstart (ADE demo) (optimization/gepa.md:47)
  - Step-by-step Integration (optimization/gepa.md:65)
    - 1. Define the signature and baseline program (optimization/gepa.md:67)
    - 2. Build datasets and evaluation helpers (optimization/gepa.md:87)
    - 3. Design a metric that returns `DSPy::Prediction` (optimization/gepa.md:99)
    - 4. (Optional) Add predictor-level feedback hooks (optimization/gepa.md:122)
    - 5. Configure the teleprompter (optimization/gepa.md:143)
      - Minibatch sizing cheat sheet (optimization/gepa.md:164)
    - 6. Compile and evaluate (optimization/gepa.md:172)
  - Reading the Outputs (optimization/gepa.md:187)
  - Advanced Configuration (optimization/gepa.md:203)
  - Guiding Principles from Agrawal et al. (2025) (optimization/gepa.md:210)
    - Applying the principles in `examples/ade_optimizer_gepa/main.rb` (optimization/gepa.md:222)
  - Troubleshooting (optimization/gepa.md:256)
  - Next Steps (optimization/gepa.md:263)
- Optimization (optimization/index.md)
  - Why Optimize? (optimization/index.md:12)
  - Optimization Guides (optimization/index.md:24)
    - [Prompt Optimization](./prompt-optimization/) (optimization/index.md:26)
    - [MIPROv2](./miprov2/) (optimization/index.md:29)
    - [Evaluation](./evaluation/) (optimization/index.md:32)
    - [Benchmarking Raw Prompts](./benchmarking-raw-prompts/) (optimization/index.md:35)
  - Getting Started (optimization/index.md:38)
- MIPROv2 Optimizer (optimization/miprov2.md)
  - Why teams reach for MIPROv2 (optimization/miprov2.md:25)
  - Quickstart (ADE demo) (optimization/miprov2.md:39)
  - Integration walkthrough (optimization/miprov2.md:59)
    - 1. Describe the task with a signature (optimization/miprov2.md:63)
    - 2. Build examples and measure a baseline (optimization/miprov2.md:90)
    - 3. Define a developer-friendly metric (optimization/miprov2.md:102)
    - 4. Pick the right preset (or customize) (optimization/miprov2.md:116)
    - 5. Compile and inspect the optimized program (optimization/miprov2.md:148)
  - Reading the outputs (optimization/miprov2.md:169)
  - Fits multi-stage programs too (optimization/miprov2.md:178)
  - Field notes from the MIPRO paper (optimization/miprov2.md:188)
  - Production checklist (optimization/miprov2.md:198)
- Prompt Optimization (optimization/prompt-optimization.md)
  - Overview (optimization/prompt-optimization.md:22)
  - Prompt Objects (optimization/prompt-optimization.md:30)
    - Basic Prompt Structure (optimization/prompt-optimization.md:32)
    - Prompt Components (optimization/prompt-optimization.md:58)
  - Manipulating Prompts (optimization/prompt-optimization.md:81)
    - Modifying Instructions (optimization/prompt-optimization.md:83)
    - Working with Few-Shot Examples (optimization/prompt-optimization.md:97)
    - Combining Modifications (optimization/prompt-optimization.md:132)
  - Automatic Prompt Optimization (optimization/prompt-optimization.md:145)
    - Using MIPROv2 for Prompt Optimization (optimization/prompt-optimization.md:147)
  - Prompt Analysis (optimization/prompt-optimization.md:179)
    - Analyzing Prompt Performance (optimization/prompt-optimization.md:181)
    - Few-Shot Example Impact (optimization/prompt-optimization.md:210)
  - Prompt Generation (optimization/prompt-optimization.md:231)
    - Instruction Variations (optimization/prompt-optimization.md:233)
    - Example Selection Strategies (optimization/prompt-optimization.md:270)
  - Advanced Prompt Techniques (optimization/prompt-optimization.md:304)
    - Progressive Prompting (optimization/prompt-optimization.md:306)
    - Context-Aware Prompting (optimization/prompt-optimization.md:338)
  - Integration with Storage (optimization/prompt-optimization.md:373)
    - Saving Prompt Configurations (optimization/prompt-optimization.md:375)
    - Loading and Reusing Prompts (optimization/prompt-optimization.md:399)
  - Best Practices (optimization/prompt-optimization.md:425)
    - 1. Systematic Testing (optimization/prompt-optimization.md:427)
    - 2. Incremental Improvement (optimization/prompt-optimization.md:458)
    - 3. Use Optimization Algorithms (optimization/prompt-optimization.md:491)